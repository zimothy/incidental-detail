------------------------------------------------------------------------------
-- Incidental Detail, a library for generating details of the incidental kind.
--
-- Victoria University of Welling, ECS
--    Richard Roberts
--    Timothy Jones
--    John Lewis
------------------------------------------------------------------------------

module Main where

-- Standard
import Data.Tree
import Data.Matrix
import Text.Printf

-- Source
import DetailGen
import PointSelect
import Selection
import Transform

------------------------------------------------------------------------------
makeDelims :: String -> String
makeDelims d = "# " ++  concat (take 76 $ repeat d) ++ " #"


------------------------------------------------------------------------------
preamble :: String -> String
preamble n = unlines [delims, comment, delims, "", importMC, "", def]
    where delims   = makeDelims "-"
          comment  = printf "# %s, generated by IDG." n
          importMC = "import maya.cmds as cmds"
          def      = "def generate():"


------------------------------------------------------------------------------
cmdFromShape :: Shape -> String
cmdFromShape Cube     = "cmds.polyCube(w=1, h=1, d=1)"
cmdFromShape Cylinder = "cmds.polyCylinder(r=0.5, h=1)"


------------------------------------------------------------------------------
getShape :: Detail -> Shape
getShape (Detail s _ _) = s


------------------------------------------------------------------------------
getPoints :: Detail -> [Point]
getPoints (Detail _ p _) = toPoints p


------------------------------------------------------------------------------
getScale :: Detail -> Double
getScale (Detail _ _ s) = s

------------------------------------------------------------------------------
getLabel :: Tree Detail -> Detail
getLabel = rootLabel


------------------------------------------------------------------------------
getSub :: Tree Detail -> Forest Detail
getSub = subForest


------------------------------------------------------------------------------
formMatrix :: Point -> Matrix Double
formMatrix p = t * r * s * (identity 4)
    where t = translate loc
          r = rotBetween (1, 0, 0) up
          s = scale (0.65, 0.25, 0.25)
          loc = location p
          up  = upVector p


------------------------------------------------------------------------------
expand :: Int -> Detail -> Forest Detail -> Matrix Double -> Point -> IO ()
expand l label sub pMtx p = do
    putStrLn $ show p
    let newM = dotM (formMatrix p) pMtx
    mapM_ (unwrapTree newM (l + 1)) sub

    appendFile "basic.py" $ printf "    %s\n" (cmdFromShape (getShape label))
    appendFile "basic.py" $ printf "    cmds.xform(m = %s)\n" $ show (mtxToArr4 (transpose newM))

    return ()


------------------------------------------------------------------------------
unwrapTree :: Matrix Double -> Int -> Tree Detail -> IO ()
unwrapTree m l x = do
    let cLabel = getLabel x
    let cSub =  getSub x
    let points = getPoints cLabel

    mapM_ (expand l cLabel cSub m) points

    return ()

------------------------------------------------------------------------------
main :: IO ()
main = do
    let sphereThenCylinder = do {
        detail Cylinder (CubeFaces yAxis) 0.3 ;
        detail Cylinder (CubeFaces xAxis) 0.3 }
    let cubeThenCylinder = do {
        detail Cube (CubeFaces xAxis) 0.1 ;
        detail Cube (CubeFaces zAxis) 0.9 }
    let applyDetail = do {
        detail Cube (CylinderLoop 8 0.5) 0.2 ;
        detail Cube (CylinderLoop 8 0.5) 0.2 }
        --branch [sphereThenCylinder ] }
        --branch [sphereThenCylinder, cubeThenCylinder] ;
        --detail Cube (CylinderLoop 4 0.2) 0.4 }

    writeFile "basic.py" (preamble "Basic")
    unwrapTree (identity 4) 0 $ head (runDetailGen applyDetail)



------------------------------------------------------------------------------