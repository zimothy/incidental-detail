------------------------------------------------------------------------------
-- | Maya Python building utilities.
module Graphics.DetailGen.Maya
    ( writeForest
    ) where

------------------------------------------------------------------------------
import qualified Data.ByteString.UTF8 as BS
import qualified System.IO.Streams    as Stream

------------------------------------------------------------------------------
import Data.ByteString   (ByteString)
import Data.Matrix       (Matrix, transpose)
import Data.Monoid       ((<>))
import Data.Tree         (Forest, Tree (..))

------------------------------------------------------------------------------
import Graphics.DetailGen.Monad (Detail (..), Shape (..))
import Graphics.DetailGen.Point
import Graphics.DetailGen.PointSelection
import Graphics.DetailGen.Vec3


------------------------------------------------------------------------------
writeForest
    :: FilePath -> Matrix Double -> Vec3 -> Int -> Forest Detail -> IO ()
writeForest fp fd m s l = Stream.withFileAsOutput fp $
    writeForest' fp fd m s l. writeln >> Stream.write Nothing
  where writeln o ln = Stream.write (Just ln) o >> Stream.write (Just "\n") o


------------------------------------------------------------------------------
type WriteLn = ByteString -> IO ()


------------------------------------------------------------------------------
writeForest'
    :: FilePath -> Matrix Double -> Vec3 -> Int -> Forest Detail -> WriteLn
    -> IO ()
writeForest' fp m s l fd writeln = do
    writePreamble fp writeln
    mapM_ (unwrapTree m s l writeln) fd


------------------------------------------------------------------------------
-- | Given the name of the file, writes a preamble.
writePreamble :: FilePath -> WriteLn -> IO ()
writePreamble fp writeln = do
    writeln $ "# " <> BS.fromString fp <> ", generated by IDG"
    writeln "import maya.cmds as cmds"
    writeln "def groupNodesUnder(grp, n):"
    writeln "  cmds.group(grp, n='groupFor__' + n)"
    writeln "def generate():"


------------------------------------------------------------------------------
writeGroupingFor :: ByteString -> WriteLn -> IO ()
writeGroupingFor g = ($ "  groupNodesUnder(" <> g <> ", '" <> g <> "')")


------------------------------------------------------------------------------
unwrapTree :: Matrix Double -> Vec3 -> Int -> WriteLn -> Tree Detail -> IO ()
unwrapTree m s l writeln x = do
    writeln $ group <> " = []"
    mapM_ (expand l root children m pScale gScale up' writeln) points'
    writeGroupingFor group writeln
  where
    root = rootLabel x
    children = subForest x
    points = toPoints $ detailSelection root
    points' = map (\(Point a b) -> (Point (dotMV (scale s) a) b)) points
    gScale = detailGScale root
    pScale = detailPScale root
    up' = detailUp root
    group = "nodes_" <> bsShow l <> "_"


------------------------------------------------------------------------------
formMatrix :: Point -> Vec3 -> Vec3 -> Matrix Double
formMatrix p gScale upV = t * r * s
  where
    t = translate loc
    r = rotBetween upV up'
    s = scale gScale
    loc = location p
    up' = upVector p


------------------------------------------------------------------------------
expand
    :: Int -> Detail -> Forest Detail -> Matrix Double -> Vec3 -> Vec3 -> Vec3
    -> WriteLn -> Point -> IO ()
expand l label sub pMtx pScale gScale up' writeln p = do
    writeln $ "  " <> group <> " += [" <> cmd <> "[0]]"
    writeln $ "  cmds.xform(m = " <> bsShow (mtxToArr4 scaled) <> ")"
    mapM_ (unwrapTree newM pScale (l + 1) writeln) sub
  where
    group = "nodes_" <> bsShow l <> "_"
    cmd = cmdFromShape (detailShape label)
    newM = pMtx * formMatrix p gScale up'
    scaled = transpose $ pMtx * formMatrix p gScale up' * scale pScale


------------------------------------------------------------------------------
cmdFromShape :: Shape -> ByteString
cmdFromShape Cube     = "cmds.polyCube(w=2, h=2, d=2)"
cmdFromShape Cylinder = "cmds.polyCylinder(r=1, h=2)"
cmdFromShape Sphere   = "cmds.polySphere(r=1)"


------------------------------------------------------------------------------
bsShow :: Show a => a -> ByteString
bsShow = BS.fromString . show

